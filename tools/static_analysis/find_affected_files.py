"""
********************************************************************************
* Copyright (C) 2018-2025 by Pavel Kisliak                                     *
* This file is part of BitSerializer library, licensed under the MIT license.  *
********************************************************************************
"""
import os
import re
import sys

def find_affected_sources(ninja_deps_file, headers):
    """
    Parse the deps.txt file to find source files that depend on the given headers.

    :param ninja_deps_file: Path to the deps.txt file generated by ninja.
    :param headers: List of modified header files.
    :return: List of affected source files.
    """
    with open(ninja_deps_file, 'r') as f:
        content = f.readlines()

    # Find all source files which references required headers
    affected_sources = {}
    i = 0
    while i < len(content):
        line = content[i].strip()
        if re.match(r'^[^:]+\.obj:', line):
            # Transform a path referencing a Cmake build directory to the corresponding source directory
            cmake_build_path = line[: line.find('.obj:')]
            cmake_component = cmake_build_path[cmake_build_path.find("CMakeFiles/") : cmake_build_path.rfind('.dir/') + 5]
            src_path = cmake_build_path.replace(cmake_component, "")
            i += 1

            while i < len(content) and not ".obj" in content[i]:
                next_line = content[i].strip()
                for header in headers:
                    if header in next_line:
                        if not header in affected_sources:
                            affected_sources[header] = [];
                        affected_sources[header].append(src_path)
                        break
                i += 1
        else:
            i += 1

    # Take only one best suitable source file for each header
    result = [];
    for key, src_files in affected_sources.items():
        file_title = key.split('/')[-1].split('.', 1)[0]
        best_candidate = None;
        for src_file in src_files:
            # The best match is a file with implementation (stop search)
            if file_title + ".cpp" in src_file:
                best_candidate = src_file
                break
            # File with corresponding tests is also suit well
            if file_title + '_tests' in src_file or file_title + '_api_tests' in src_file:
                best_candidate = src_file
            # Or at least contain header title
            if best_candidate == None and file_title in src_file:
                best_candidate = src_file

        if best_candidate != None:
            result.append(best_candidate)
        else:
            result.append(src_files[0])
    return result

if __name__ == "__main__":
    if len(sys.argv) < 3 or len(sys.argv) > 4:
        print("Usage: python find_affected_files.py <ninja_deps_file> <changed_files_file> <output_file>")
        sys.exit(1)

    ninja_deps_file = sys.argv[1]
    changed_files_file = sys.argv[2]
    output_file = sys.argv[3] if len(sys.argv) > 3 else 'affected_sources.txt'

    with open(changed_files_file, 'r') as f:
        changed_files = f.read().splitlines()

    headers = [file for file in changed_files if re.match(r'.*\.(h|hpp)$', file)]
    sources = [file for file in changed_files if re.match(r'.*\.(cpp|cc)$', file)]

    if headers:
        affected_sources = find_affected_sources(ninja_deps_file, headers)
        all_sources = set(sources + affected_sources)
    else:
        all_sources = set(sources)

    with open(output_file, 'w') as f:
        f.write('\n'.join(all_sources))
    print(f"Affected source files ({len(all_sources)}) saved to: {output_file}")
